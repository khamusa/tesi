Riassunto Elaborato Finale
==========================

Titolo: Progettazione di un'applicazione e conseguenze di un approccio ``continuous refactoring''.

``Experience is simply the name we give our mistakes.'' - Oscar Wilde

L'obbiettivo di questo elaborato è quello di documentare parte del processo di sviluppo dell'applicazione Spazi Unimi, discorrere su un sottoinsieme delle sfide trovate durante la progettazione e le soluzioni trovate. In particolare parlo dell'uso del refactoring come attività di design a posteriori.

Spazi Unimi è il nome dato a un progetto per l'ottenimento di dati sugli spazi dell’Università degli Studi di Milano, sviluppato durante il Tirocinio Interno per la laurea triennale in Informatica all’UNIMI, da Samuel Gomes Brandão, Diego Costantino e Paolo Venturi. L'idea nasce a partire dalle proposte del progetto Campus Sostenibile, promosso dall’UNIMI e dal Politecnico di Milano, e si sviluppa successivamente in autonomia, sotto l'orientamento del Prof. Dr. Carlo Bellettini.

La necessità base da soddisfare è quella di fornire agli utenti universitari, cioè insegnanti, studenti, ricercatori, visitatori e addetti, informazioni utili alla localizzazione delle stanze e locali di loro interesse, indicando su una mappa interattiva non solo l'edificio in cui è inserito il locale desiderato, ma anche la sua posizione all'interno della pianta architettonica. 
Siamo partiti dai casi d'uso degli utenti e abbiamo proceduto verso la comprensione dei dati e delle informazioni disponibili, con un approccio iniziale che ho denominato ``Exploration Driven''.

Il nostro flusso di lavoro è stato basato sull'Extreme Programming, con uso del TDD nella sua maggior parte. Abbiamo praticato estensiva attività di testing e in particolare mi sono concentrato su quella di refactoring. Il capitolo 3 - ``La scelta di un workflow'' parla di questi aspetti, delle difficoltà applicative del TDD nel nostro progetto e della sperimentazione con l'uso della REPL come guida allo sviluppo.

Siamo stati in grado di estrarre le informazioni necessarie delle piante architettoniche fornite dal dipartimento di edilizia dell'università, ed incrociarle con altri dati rilevanti sull'uso degli spazi universitari. Abbiamo conquistato questi obbiettivi attraverso l'applicazione di diverse euristiche per la validazione e correzione dei dati iniziali in input, spesso inconsistenti.

L'argomento principale del capitolo 4 è il nostro confronto con il ``Software Decay''. A un certo punto del progetto mi sono accorto che il nostro codice diventava complesso, e ci sentivamo meno capaci di sistemarlo. Allo stesso tempo, non eravamo in grado di capire i motivi per cui fossimo arrivati a quel punto, dato che avevamo dedicato molta attenzione al design del sistema. 

Percepivamo la presenza dei problemi, in particolare in forma di code smells, ma non eravamo in grado di trovarne l'origine - ci mancava l'esperienza. Mi sono allora messo il compito di trovare aiuto in letteratura, di cercare l'inspirazione che ci aiutasse ad identificare i problemi e le relative soluzioni.

Sono partito rileggendo dei concetti base di progettazione del software, in particolare i principi SOLID, il principio KISS e DRY. Non si trattano di design patterns complessi o soluzioni pronte, ma piuttosto dei concetti molto  basilari, linee guida intese ad aiutare il progettista ad identificare i problemi del proprio codice. Sono infatti una misura per la qualità del software. 

All'applicazione di ognuno di questi concetti al codebase, seguiva un'operazione di refactoring: in poche parole, sapendo che cosa cercare nel nostro codice, sono stato in grado di ricavare l'origine dei problemi.

Il refactoring è l'attività di cambiare il codice esistente senza alterarne la sua funzionalità, con lo scopo di perfezionarlo: aumentare la leggibilità, ``mantenibilità'' o ``testabilità''.

Da questa esperienza ho tratto un'importante conclusione riguardo ai motivi per cui i nostri sforzi di costruire sempre del design di qualità non avevano avuto il successo atteso. Abbiamo spesso applicato la tecnica del design in anticipo, cioè la progettazione del software prima della sua scrittura, ma non siamo stati così attenti alla manutenzione del design in seguito alle mutazioni e estensioni del codice esistente. Questi aspetti li formalizzo nel capitolo 5 - ``Refactoring Continuo e Guidato''.

Il codice ha un ciclo di vita, quale viene creato e va mantenuto. Come risultato finale di queste riflessioni sono arrivato al concetto di ``continuous refactoring''. Per questo concetto intendo l'applicazione sistematica, metodologica e a piccoli passi delle tecniche di refactoring. Il refactoring non va visto soltanto come una strategia per correggere i difetti già presenti, ma come un'attività di design stessa - non è per caso che è uno dei passi cardine del TDD. La sua applicazione non può essere casuale ma metodologica, basata su concetti semplici e sufficientemente generici che definiscano le caratteristiche che consideriamo desiderabili da un buon design. La scelta di questi principi va vincolata ai paradigmi di programmazione e alle nature specifiche del progetto.

Una volta conferito al refactoring dignità di processo, con la sua applicazione continua a diversi livelli di granularità abbiamo ottenuto moduli più organizzati, con le dipendenze contenute, e un'ultima particolare caratteristica che adesso considero quella più importante: codice auto-documentante.

Ad ogni iterazione di refactoring abbiamo una nuova opportunità per migliorare l'espressività del codice. Lo scopo è costruire codice in grado di esprimere il suo scopo e la strategia utilizzata per raggiungerlo, senza necessità di ausili esterni, come commenti o documentazione formale. Vogliamo un codice in grado di esplicitare il suo proposito e il proprio flusso di esecuzione in modo semplice e diretto. Questa caratteristica è di una potenza significativa all'interno di progetti con più sviluppatori e con frequenti cambiamenti sul team, e rende significativamente più facile il rilevamento degli errori.

Partecipare a questo progetto mi ha fornito l'opportunità di
riflettere con calma sui principi della progettazione software, applicandoli
direttamente in un contesto pratico. 

Concludo questo progetto con la sensazione che l'attività di design del software non sia affatto un'attività precisa, esatta. Ci vuole del tempo per maturare la propria comprensione del sistema in questione, il proprio sguardo e la percezione dei problemi. Ci vuole non solo contemplazione e riflessione, ma anche la possibilità di fare tentativi, commettere degli errori e confrontarsi. Torno a casa con uno sguardo più maturo, con la certezza che la strada da percorrere è ancora lunga e con il dubbio che ci sia un punto finale (ma spero di no).